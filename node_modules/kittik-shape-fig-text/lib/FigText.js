'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _kittikShapeBasic = require('kittik-shape-basic');

var _kittikShapeBasic2 = _interopRequireDefault(_kittikShapeBasic);

var _figlet = require('figlet');

var _figlet2 = _interopRequireDefault(_figlet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

/**
 * Implements ASCII art text via Figlet fonts.
 *
 * @extends {Shape}
 * @since 1.0.0
 */
class FigText extends _kittikShapeBasic2.default {
  /**
   * Create ASCII-art shape.
   *
   * @constructor
   * @param {Cursor} cursor Cursor instance
   * @param {Object} [options] Options object
   * @param {String} [options.font] Figlet font that you want to use
   * @param {String} [options.horizontalLayout] A string value that indicates the horizontal layout to use
   * @param {String} [options.verticalLayout] A string value that indicates the vertical layout to use
   * @example
   * FigText.create(cursor, {
   *   text: 'Hello, World',
   *   x: 'center',
   *   y: 'middle',
   *   font: 'Ghost',
   *   horizontalLayout: 'full',
   *   verticalLayout: 'full'
   * });
   */
  constructor(cursor) {
    let options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    super(cursor, options);

    this.setFont(options.font);
    this.setHorizontalLayout(options.horizontalLayout);
    this.setVerticalLayout(options.verticalLayout);
  }

  /**
   * Get actual width of the shape.
   * Since we don't specify width of the shape, we need to calculate its sizes on our own.
   * The longest line in our shape will be our shape width.
   *
   * @override
   * @returns {Number}
   */
  getWidth() {
    const text = this._render().split('\n').map(item => item.length);
    return Math.max.apply(Math, _toConsumableArray(text));
  }

  /**
   * Get actual height of the shape.
   * Since we don't specify height of the shape, we need to calculate its sizes on our own.
   * Count of total lines in our shape will be our height.
   *
   * @override
   * @returns {Number}
   */
  getHeight() {
    return this._render().split('\n').length;
  }

  /**
   * Get font that uses for rendering text.
   *
   * @returns {String}
   */
  getFont() {
    return this.get('font');
  }

  /**
   * Set font that will be used for rendering the text.
   *
   * @param {String} [font='Standard']
   * @returns {FigText}
   */
  setFont() {
    let font = arguments.length <= 0 || arguments[0] === undefined ? 'Standard' : arguments[0];

    return this.set('font', font);
  }

  /**
   * Get horizontal layout.
   *
   * @returns {String}
   */
  getHorizontalLayout() {
    return this.get('horizontalLayout');
  }

  /**
   * Set horizontal layout.
   *
   * @param {String} [layout='default'] Can be default, full or fitted
   * @returns {FigText}
   */
  setHorizontalLayout() {
    let layout = arguments.length <= 0 || arguments[0] === undefined ? 'default' : arguments[0];

    if (['default', 'full', 'fitted'].indexOf(layout) === -1) throw new Error(`Unrecognized layout: ${ layout }`);
    return this.set('horizontalLayout', layout);
  }

  /**
   * Get vertical layout.
   *
   * @returns {String}
   */
  getVerticalLayout() {
    return this.get('verticalLayout');
  }

  /**
   * Set vertical layout.
   *
   * @param {String} [layout='default'] Can be default, full or fitted
   * @returns {FigText}
   */
  setVerticalLayout() {
    let layout = arguments.length <= 0 || arguments[0] === undefined ? 'default' : arguments[0];

    if (['default', 'full', 'fitted'].indexOf(layout) === -1) throw new Error(`Unrecognized layout: ${ layout }`);
    return this.set('verticalLayout', layout);
  }

  /**
   * Pre render the ASCII art without writing it to the cursor.
   *
   * @returns {String} Returns string of ASCII art
   * @private
   */
  _render() {
    const font = this.getFont();
    const horizontalLayout = this.getHorizontalLayout();
    const verticalLayout = this.getVerticalLayout();

    return _figlet2.default.textSync(this.getText(), { font: font, horizontalLayout: horizontalLayout, verticalLayout: verticalLayout });
  }

  /**
   * Renders the shape.
   *
   * @returns {FigText}
   */
  render() {
    const cursor = this.getCursor();
    const text = this._render().split('\n');
    const x = this.getX();
    const y = this.getY();
    const background = this.getBackground();
    const foreground = this.getForeground();

    cursor.background(background).foreground(foreground);

    text.forEach((item, index) => cursor.moveTo(x, y + index).write(item));

    return this;
  }

  /**
   * Serialize shape to object representation.
   *
   * @returns {Object}
   */
  toObject() {
    const obj = super.toObject();

    Object.assign(obj.options, {
      font: this.get('font'),
      horizontalLayout: this.get('horizontalLayout'),
      verticalLayout: this.get('verticalLayout')
    });

    return obj;
  }
}
exports.default = FigText;
module.exports = exports['default'];