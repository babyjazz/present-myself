'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keypress = require('keypress');

var _keypress2 = _interopRequireDefault(_keypress);

var _kittikCursor = require('kittik-cursor');

var _kittikCursor2 = _interopRequireDefault(_kittikCursor);

var _Slide = require('./Slide');

var _Slide2 = _interopRequireDefault(_Slide);

var _tty = require('tty');

var _tty2 = _interopRequireDefault(_tty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Deck class is responsible for managing slides and their rendering.
 *
 * @since 1.0.0
 */
class Deck {
  /**
   * Creates deck instance.
   * You can declare shapes\animations\etc at the root of the declaration.
   * It will automatically merges to each instance of the slide.
   *
   * @constructor
   * @param {Object} declaration Declaration for the deck, also consists of additional parameters to the deck
   * @param {Cursor} [declaration.cursor] Cursor instance that you want to use when rendering slides
   * @param {Array<Object>} [declaration.shapes] Array of shapes declaration will be merged into each slide
   * @param {Array<Object>} [declaration.animations] Array of animations declaration will be merged into each slide
   * @param {Array<Object>} declaration.slides Array of slides declaration
   * @example
   * Deck.create({
   *   cursor: Cursor.create(), // custom instance of the cursor
   *   shapes: [{ // global shapes will be merged into each slide and will be available there by name
   *     name: 'Global Shape',
   *     type: 'Text',
   *     options: {
   *       text: 'Hello, World'
   *     }
   *   }],
   *   animations: [{
   *     name: 'Global Animation',
   *     type: 'Print',
   *     options: {
   *       duration: 3000,
   *       easing: 'inOutElastic'
   *     }
   *   }],
   *   slides: [{ // declaration for each slide
   *     shapes: [], // local shapes applied only to current slide
   *     animations: [], // local animations applied only to current slide
   *     order: [] // order of the current slide
   *   }]
   * });
   */
  constructor() {
    let declaration = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var _declaration$cursor = declaration.cursor;
    const cursor = _declaration$cursor === undefined ? _kittikCursor2.default.create().saveScreen().reset().hideCursor() : _declaration$cursor;
    var _declaration$shapes = declaration.shapes;
    const shapes = _declaration$shapes === undefined ? [] : _declaration$shapes;
    var _declaration$animatio = declaration.animations;
    const animations = _declaration$animatio === undefined ? [] : _declaration$animatio;
    var _declaration$slides = declaration.slides;
    const slides = _declaration$slides === undefined ? [] : _declaration$slides;


    this._currentSlideIndex = 0;
    this._cursor = cursor;
    this._slides = slides.map(slide => {
      const slideShapes = shapes.concat(slide.shapes || []);
      const slideAnimations = animations.concat(slide.animations || []);
      return _Slide2.default.create(this._cursor, Object.assign(slide, { shapes: slideShapes, animations: slideAnimations }));
    });

    this._initKeyboard();
  }

  /**
   * Init keyboard and binds EventEmitter to the stdin stream.
   *
   * @private
   */
  _initKeyboard() {
    if (_tty2.default.isatty(this._cursor._stream)) {
      (0, _keypress2.default)(process.stdin);
      process.stdin.setRawMode(true);
      process.stdin.setEncoding('utf8');
      process.stdin.on('keypress', this._onKeyPress.bind(this));
    }

    return this;
  }

  /**
   * Triggers when user is pressing the key.
   *
   * @param {String} ch
   * @param {Object} key
   * @private
   */
  _onKeyPress(ch, key) {
    if (key.name == 'left') this.prevSlide();
    if (key.name == 'right' || key.name == 'space') this.nextSlide();
    if (key.ctrl && key.name == 'c') this.exit();

    return this;
  }

  /**
   * Run the presentation.
   *
   * @returns {Deck}
   */
  run() {
    this.renderSlide();
    return this;
  }

  /**
   * Renders specified slide.
   *
   * @param {Number} [index] Slide index in presentation
   * @returns {Deck}
   */
  renderSlide() {
    let index = arguments.length <= 0 || arguments[0] === undefined ? this._currentSlideIndex : arguments[0];

    if (!this._slides[index]) return this;

    this._slides[index].render();

    return this;
  }

  /**
   * Renders the next slide.
   *
   * @returns {Deck}
   */
  nextSlide() {
    if (this._currentSlideIndex + 1 > this._slides.length - 1) return this;

    this.renderSlide(++this._currentSlideIndex);
    return this;
  }

  /**
   * Renders the previous slide.
   *
   * @returns {Deck}
   */
  prevSlide() {
    if (this._currentSlideIndex - 1 < 0) return this;

    this.renderSlide(--this._currentSlideIndex);
    return this;
  }

  /**
   * Closes the presentation and returns to terminal.
   */
  exit() {
    this._cursor.showCursor().restoreScreen().reset();
    process.exit(0);
  }

  /**
   * Wrapper around `new Presentation()`.
   *
   * @param {*} args
   * @returns {Deck}
   */
  static create() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new (Function.prototype.bind.apply(this, [null].concat(args)))();
  }
}
exports.default = Deck;
module.exports = exports['default'];