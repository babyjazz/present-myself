'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _kittikAnimationBasic = require('kittik-animation-basic');

var _kittikAnimationBasic2 = _interopRequireDefault(_kittikAnimationBasic);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Dictionary of all available directions, that you can use in animation.
 *
 * @type {Object}
 * @private
 */
const AVAILABLE_DIRECTIONS = ['inUp', 'inDown', 'inLeft', 'inRight', 'outUp', 'outDown', 'outLeft', 'outRight'];

/**
 * Animation that animates sliding of the shapes.
 *
 * @extends {Animation}
 * @since 1.0.0
 */
class Slide extends _kittikAnimationBasic2.default {
  /**
   * Create Slide animation instance.
   *
   * @constructor
   * @param {Object} [options] Options object
   * @param {String} [options.direction] Direction of the animation
   * @example
   * Slide.create({
   *   direction: 'inLeft'
   * }).animate(someShapeInstance);
   */
  constructor() {
    let options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    super(options);

    this.setDirection(options.direction);
  }

  /**
   * Get direction of the animation.
   *
   * @returns {String}
   */
  getDirection() {
    return this.get('direction');
  }

  /**
   * Set new direction of the animation.
   *
   * @param {String} direction
   * @returns {Slide}
   */
  setDirection() {
    let direction = arguments.length <= 0 || arguments[0] === undefined ? 'inRight' : arguments[0];

    if (AVAILABLE_DIRECTIONS.indexOf(direction) === -1) throw new Error(`Unknown direction: ${ direction }`);
    return this.set('direction', direction);
  }

  /**
   * Get shape instance and calculate startX, startY, endX and endY coordinates based on direction.
   *
   * @param {Shape} shape
   * @returns {Object} Returns an object with startX, startY, endX, endY properties
   * @private
   */
  _parseCoordinates(shape) {
    const cursor = shape.getCursor();
    const directions = {
      inUp: () => [shape.getX(), -shape.getHeight(), shape.getX(), shape.getY()],
      inDown: () => [shape.getX(), cursor._height + shape.getHeight(), shape.getX(), shape.getY()],
      inLeft: () => [-shape.getWidth(), shape.getY(), shape.getX(), shape.getY()],
      inRight: () => [cursor._width + shape.getWidth(), shape.getY(), shape.getX(), shape.getY()],
      outUp: () => [shape.getX(), shape.getY(), shape.getX(), -shape.getHeight()],
      outDown: () => [shape.getX(), shape.getY(), shape.getX(), cursor._height + shape.getHeight()],
      outLeft: () => [shape.getX(), shape.getY(), -shape.getWidth(), shape.getY()],
      outRight: () => [shape.getX(), shape.getY(), cursor._width + 1, shape.getY()]
    };

    var _directions$getDirect = directions[this.getDirection()]();

    var _directions$getDirect2 = _slicedToArray(_directions$getDirect, 4);

    const startX = _directions$getDirect2[0];
    const startY = _directions$getDirect2[1];
    const endX = _directions$getDirect2[2];
    const endY = _directions$getDirect2[3];

    return { startX, startY, endX, endY };
  }

  /**
   * Main method that calls when shape need to be animated.
   *
   * @override
   * @param {Shape} shape
   * @returns {Promise}
   * @fulfil {Shape} When animation is done, fulfils with the Shape instance
   */
  animate(shape) {
    var _parseCoordinates = this._parseCoordinates(shape);

    const startX = _parseCoordinates.startX;
    const startY = _parseCoordinates.startY;
    const endX = _parseCoordinates.endX;
    const endY = _parseCoordinates.endY;


    return Promise.all([this.animateProperty({ shape: shape, property: 'x', startValue: startX, endValue: endX }), this.animateProperty({ shape: shape, property: 'y', startValue: startY, endValue: endY })]).then(() => Promise.resolve(shape));
  }

  /**
   * Serializes animation to Object representation.
   *
   * @override
   * @returns {Object}
   */
  toObject() {
    const obj = super.toObject();

    Object.assign(obj.options, {
      direction: this.get('direction')
    });

    return obj;
  }
}
exports.default = Slide;
module.exports = exports['default'];